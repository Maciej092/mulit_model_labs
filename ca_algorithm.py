import numpy as np
from copy import deepcopy as dp


class CellularAutomata:
    def __init__(self, number_of_grains, number_of_inclusions, radius_min, radius_max, space_width, space_length, border_rule, string):
        self.MOORE = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))
        self.VONNEUMANN = ((-1, 0), (0, -1), (0, 1), (1, 0))
        self.HEXAGONAL_LEFT = ((-1, -1), (-1, 0), (0, -1), (0, 1), (1, 0), (1, 1))
        self.HEXAGONAL_RIGHT = ((-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0))
        self.PENTAGONAL_LEFT = ((-1, -1), (-1, 0), (0, -1), (1, -1), (1, 0))
        self.PENTAGONAL_RIGHT = ((-1, 0), (-1, 1), (0, 1), (1, 0), (1, 1))
        self.border_rule = border_rule                     # Border rule is entered from the gui
        self.number_of_grains = number_of_grains           # Number of random seeds generated by add_random func.
        self.number_of_inclusions = number_of_inclusions   # Number of inclusions.
        self.number_of_reserved_ids = 3
        self.radius_max = radius_max                       # Max radius of inclusions.
        self.radius_min = radius_min                       # Min radius of inclusions.
        self.space_width = space_width                     # Variable used to specify the size of CA space
        self.space_length = space_length                   # Currently this var is useless
        self.space = np.zeros((self.space_width, self.space_width), dtype=np.uint8)    # Main space of CA algorithm
        self.space_prev = np.zeros((self.space_width, self.space_width), dtype=np.uint8)
        self.space_clear = np.zeros((self.space_width, self.space_width))    # Clear space. Used in the gui
        self.cell_empty = 0
        self.cell_inclusion = 1
        self.neighbours = self.choose_neighbours(string)
        self.color_id = list()                                # List of RGB colors. Generation is executed in add_random func.
        self.list_of_id = set()                               # Set of the IDs ( integer values ): for deleting reason
        self.grain_model = dict()                             # Here will be stored the number of id and the phase of the each grain
        self.phase_zero = 0
        self.phase_nonzero = 1

    @staticmethod
    def evaluate_id(nei_list):                                # Choose the id which is the most frequent in neighbourhood
        counter = 0
        if nei_list[0] == 1:
            num = 0
        else:
            num = nei_list[0]
        for i in nei_list:
            if i > 1:
                curr_frequency = nei_list.count(i)
                if curr_frequency > counter:
                    counter = curr_frequency
                    num = i
        return int(num)

    def choose_neighbours(self, string):  # Choose the neighbourhood method
        if 'MOORE' == string:
            neighbours = self.MOORE
        elif 'VONNEUMANN' == string:
            neighbours = self.VONNEUMANN
        elif 'HEXAGONAL_LEFT' == string:
            neighbours = self.HEXAGONAL_LEFT
        elif 'HEXAGONAL_RIGHT' == string:
            neighbours = self.HEXAGONAL_RIGHT
        elif 'PENTAGONAL_LEFT' == string:
            neighbours = self.PENTAGONAL_LEFT
        elif 'PENTAGONAL_RIGHT' == string:
            neighbours = self.PENTAGONAL_RIGHT
        else:
            neighbours = self.VONNEUMANN
        return neighbours

    def add_random(self):
        self.color_id.append(np.array([255, 255, 255]))    # White color - reserved/ blank space
        self.color_id.append(np.array([0, 0, 0]))          # Black color - reserved/ inclusion color
        self.color_id.append(np.array([255, 20, 147]))     # Pink color  - reserved/ dual phase color
        self.grain_model.setdefault(0, 0)
        self.grain_model.setdefault(1, 1)
        self.grain_model.setdefault(2, 1)
        for i in range(self.number_of_grains):
            color = np.random.randint(0, 230, 3)           # Generate the list of random RGB colors
            self.color_id.append(color)
            self.grain_model.setdefault(i+self.number_of_reserved_ids, 0)
        for i in range(self.number_of_grains):
            random_x = np.random.randint(self.space_width - 1)
            random_y = np.random.randint(self.space_width - 1)
            random_id = np.random.randint(self.number_of_reserved_ids, self.number_of_grains + self.number_of_reserved_ids)
            self.space[random_x, random_y] = random_id
            self.list_of_id.add(random_id)
            self.grain_model.setdefault(random_id, self.phase_zero)
        return self.color_id

    def add_inclusions(self):
        n = self.space_width
        user_min_radius = self.radius_min
        user_max_radius = self.radius_max
        number = self.number_of_inclusions
        for num in range(number):
            max_radius = np.random.randint(user_min_radius, user_max_radius + 1)
            a, b = np.random.randint(n - max_radius), np.random.randint(n - max_radius)
            y, x = np.ogrid[-a:n - a, -b:n - b]
            mask = x * x + y * y <= max_radius * max_radius
            self.space[mask] = 1

    def add_random_dual_phase(self):
        for i in range(self.number_of_grains):
            random_x = np.random.randint(self.space_width - 1)
            random_y = np.random.randint(self.space_width - 1)
            random_id = np.random.randint(self.number_of_reserved_ids, self.number_of_grains + self.number_of_reserved_ids)
            if self.space[random_x, random_y] == 0:
                self.space[random_x, random_y] = random_id

    def one_step(self):                                    # One cellular automaton step
        self.space_prev = dp(self.space)
        for x in range(self.space_width):
            for y in range(self.space_width):
                if self.grain_model[self.space_prev[x, y]] == self.phase_zero and self.space_prev[x, y] == self.cell_empty:
                    nei_list = list()
                    for neigh in self.neighbours:
                        xn, yn = neigh
                        if 'ABSORBING' == self.border_rule:
                            if (x + xn) < 0 or (y + yn) < 0 or (x + xn) >= self.space_width or (y + yn) >= self.space_width:
                                nei_list.append(0)
                            else:
                                if self.grain_model[self.space_prev[x+xn, y+yn]] == self.phase_zero:
                                    nei_list.append(self.space_prev[x+xn, y+yn])
                        else:
                            if self.grain_model[self.space_prev[(x + xn) % self.space_width, (y + yn) % self.space_width]] == self.phase_zero:
                                nei_list.append(self.space_prev[(x + xn) % self.space_width, (y + yn) % self.space_width])
                    if sum(nei_list) > 0:
                        self.space[x, y] = self.evaluate_id(nei_list)
                    else:
                        self.space[x, y] = 0
                elif self.grain_model[self.space_prev[x, y]] == self.phase_nonzero:
                    continue
                else:
                    continue
        return self.space

