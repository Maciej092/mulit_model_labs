import numpy as np
from copy import deepcopy as dp


class CellularAutomata:
    def __init__(self, number, space_width, space_length,  border_rule, string):
        self.MOORE = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))
        self.VONNEUMANN = ((-1, 0), (0, -1), (0, 1), (1, 0))
        self.border_rule = border_rule                     # Border rule is entered from the gui
        self.number = number                               # Number of random seeds generated by add_random func.
        self.space_width = space_width                     # Variable used to specify the size of CA space
        self.space_length = space_length                   # Currently this var is useless
        self.space = np.zeros((self.space_width, self.space_width))    # Main space of CA algorithm
        self.space_clear = np.zeros((self.space_width, self.space_width))    # Clear space. Used in the gui
        self.cell_empty = 0
        self.neighbours = self.choose_neighbours(string)
        self.color_id = []                                 # List of RGB colors. Generation is executed in add_random func.

    @staticmethod
    def evaluate_id(nei_list):                             # Choose the id which is the most frequent in neighbourhood
        counter = 0
        num = nei_list[0]
        for i in nei_list:
            if i > 0:
                curr_frequency = nei_list.count(i)
                if curr_frequency > counter:
                    counter = curr_frequency
                    num = i
        return num

    def choose_neighbours(self, string):                   # Choose the neighbourhood method
        if string == 'MOORE':
            neighbours = self.MOORE
        else:
            neighbours = self.VONNEUMANN
        return neighbours

    def add_random(self):
        self.color_id.append(np.array([255, 255, 255]))    # White color - reserved/ blank space
        self.color_id.append(np.array([0, 0, 0]))          # Black color - inclusion color
        for i in range(self.number):                       # Generate the list of random RGB colors
            self.color_id.append(np.random.randint(0, 255, 3))
        for i in range(self.number):
            random_x = np.random.randint(self.space_width - 1)
            random_y = np.random.randint(self.space_width - 1)
            self.space[random_x, random_y] = i + 2
        return self.color_id

    def one_step(self):                                    # One cellular automaton step
        space_prev = dp(self.space)
        for x in range(self.space_width):
            for y in range(self.space_width):
                if space_prev[x, y] == self.cell_empty:
                    nei_list = []
                    for neigh in self.neighbours:
                        xn, yn = neigh
                        if self.border_rule == 'ABSORBING':
                            if (x + xn) < 0 or (y + yn) < 0 or (x + xn) >= self.space_width or (y + yn) >= self.space_width:
                                nei_list.append(0)
                            else:
                                nei_list.append(space_prev[x+xn, y+yn])
                        else:
                            nei_list.append(space_prev[(x + xn) % self.space_width, (y + yn) % self.space_width])
                    if sum(nei_list) > 0:
                        self.space[x, y] = self.evaluate_id(nei_list)
                    else:
                        self.space[x, y] = 0

