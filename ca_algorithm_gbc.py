import numpy as np
from copy import deepcopy as dp


class CellularAutomataGBC:
    def __init__(self, number_of_grains, number_of_inclusions,
                 radius_min, radius_max,
                 space_width, space_length,
                 border_rule, probability_threshold):
        self.MOORE = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))
        self.MOORE_NEAREST = ((-1, 0), (0, -1), (0, 1), (1, 0))
        self.MOORE_FURTHER = ((-1, -1), (-1, 1), (1, -1), (1, 1))
        self.border_rule = border_rule  # Border rule is entered from the gui
        self.number_of_grains = number_of_grains  # Number of random seeds generated by add_random func.
        self.number_of_inclusions = number_of_inclusions  # Number of inclusions.
        self.number_of_reserved_ids = 3
        self.radius_max = radius_max  # Max radius of inclusions.
        self.radius_min = radius_min  # Min radius of inclusions.
        self.space_width = space_width  # Variable used to specify the size of CA space
        self.space_length = space_length  # Currently this var is useless
        self.space = np.zeros((self.space_width, self.space_width), dtype=np.uint8)  # Main space of CA algorithm
        self.space_prev = np.zeros((self.space_width, self.space_width), dtype=np.uint8)
        self.space_clear = np.zeros((self.space_width, self.space_width))  # Clear space. Used in the gui
        self.cell_empty = 0
        self.cell_inclusion = 1
        self.color_id = list()  # List of RGB colors. Generation is executed in add_random func.
        self.list_of_id = set()  # Set of the IDs ( integer values ): for deleting reason
        self.grain_model = dict()  # Here will be stored the number of id and the phase of the each grain
        self.phase_zero = 0
        self.phase_nonzero = 1
        self.probability_threshold = probability_threshold

    def add_random(self):
        self.color_id.append(np.array([255, 255, 255]))  # White color - reserved/ blank space
        self.color_id.append(np.array([0, 0, 0]))  # Black color - reserved/ inclusion color
        self.color_id.append(np.array([255, 20, 147]))  # Pink color  - reserved/ dual phase color
        self.grain_model.setdefault(0, 0)
        self.grain_model.setdefault(1, 1)
        self.grain_model.setdefault(2, 1)
        for i in range(self.number_of_grains):
            color = np.random.randint(0, 230, 3)  # Generate the list of random RGB colors
            self.color_id.append(color)
            self.grain_model.setdefault(i + self.number_of_reserved_ids, 0)
        for i in range(self.number_of_grains):
            random_x = np.random.randint(self.space_width - 1)
            random_y = np.random.randint(self.space_width - 1)
            random_id = np.random.randint(self.number_of_reserved_ids,
                                          self.number_of_grains + self.number_of_reserved_ids)
            self.space[random_x, random_y] = random_id
            self.list_of_id.add(random_id)
            self.grain_model.setdefault(random_id, self.phase_zero)
        return self.color_id

    def add_inclusions(self):
        n = self.space_width
        user_min_radius = self.radius_min
        user_max_radius = self.radius_max
        number = self.number_of_inclusions
        for num in range(number):
            max_radius = np.random.randint(user_min_radius, user_max_radius + 1)
            a, b = np.random.randint(n - max_radius), np.random.randint(n - max_radius)
            y, x = np.ogrid[-a:n - a, -b:n - b]
            mask = x * x + y * y <= max_radius * max_radius
            self.space[mask] = 1

    def add_random_dual_phase(self):
        for i in range(self.number_of_grains):
            random_x = np.random.randint(self.space_width - 1)
            random_y = np.random.randint(self.space_width - 1)
            random_id = np.random.randint(self.number_of_reserved_ids,
                                          self.number_of_grains + self.number_of_reserved_ids)
            if self.space[random_x, random_y] == 0:
                self.space[random_x, random_y] = random_id

    def check_rule_1(self, space_prev, x, y):
        self.neighbours = self.MOORE
        nei_list = list()
        for neigh in self.neighbours:
            xn, yn = neigh
            if 'ABSORBING' == self.border_rule:
                if (x + xn) < 0 or (y + yn) < 0 or (x + xn) >= self.space_width or (y + yn) >= self.space_width:
                    nei_list.append(0)
                else:
                    nei_list.append(space_prev[x + xn, y + yn])
            else:
                nei_list.append(space_prev[(x + xn) % self.space_width, (y + yn) % self.space_width])
        if sum(nei_list) > 0:
            self.space[x, y] = self.evaluate_id_rule_1(nei_list)
        else:
            self.space[x, y] = 0
        return self.space[x, y]

    def check_rule_2(self, space_prev, x, y):
        self.neighbours = self.MOORE_NEAREST
        nei_list = list()
        for neigh in self.neighbours:
            xn, yn = neigh
            if 'ABSORBING' == self.border_rule:
                if (x + xn) < 0 or (y + yn) < 0 or (x + xn) >= self.space_width or (y + yn) >= self.space_width:
                    nei_list.append(0)
                else:
                    nei_list.append(space_prev[x + xn, y + yn])
            else:
                nei_list.append(space_prev[(x + xn) % self.space_width, (y + yn) % self.space_width])
        if sum(nei_list) > 0:
            self.space[x, y] = self.evaluate_id_rule_2(nei_list)
        else:
            self.space[x, y] = 0
        return self.space[x, y]

    def check_rule_3(self, space_prev, x, y):
        self.neighbours = self.MOORE_FURTHER
        nei_list = list()
        for neigh in self.neighbours:
            xn, yn = neigh
            if 'ABSORBING' == self.border_rule:
                if (x + xn) < 0 or (y + yn) < 0 or (x + xn) >= self.space_width or (y + yn) >= self.space_width:
                    nei_list.append(0)
                else:
                    nei_list.append(space_prev[x + xn, y + yn])
            else:
                nei_list.append(space_prev[(x + xn) % self.space_width, (y + yn) % self.space_width])
        if sum(nei_list) > 0:
            self.space[x, y] = self.evaluate_id_rule_3(nei_list)
        else:
            self.space[x, y] = 0
        return self.space[x, y]

    def check_rule_4(self, space_prev, x, y):
        self.neighbours = self.MOORE
        nei_list = list()
        for neigh in self.neighbours:
            xn, yn = neigh
            if 'ABSORBING' == self.border_rule:
                if (x + xn) < 0 or (y + yn) < 0 or (x + xn) >= self.space_width or (y + yn) >= self.space_width:
                    nei_list.append(0)
                else:
                    nei_list.append(space_prev[x + xn, y + yn])
            else:
                nei_list.append(space_prev[(x + xn) % self.space_width, (y + yn) % self.space_width])
        if sum(nei_list) > 0:
            self.space[x, y] = self.evaluate_id_rule_4(nei_list, self.probability_threshold)
            return self.space[x, y]
        else:
            self.space[x, y] = 0
            return 0

    @staticmethod
    def evaluate_id_rule_1(nei_list):  # Choose the id which is the most frequent in neighbourhood
        counter = 0
        if nei_list[0] == 1:
            num = 0
        else:
            num = nei_list[0]
        for i in nei_list:
            if i > 1:
                curr_frequency = nei_list.count(i)
                if curr_frequency > counter:
                    counter = curr_frequency
                    num = i
        if num > 1:
            num_of_nums = nei_list.count(num)
            if 5 <= num_of_nums <= 8:
                return int(num)
            else:
                return 0
        else:
            return 0

    @staticmethod
    def evaluate_id_rule_2(nei_list):  # Choose the id which is the most frequent in neighbourhood
        counter = 0
        if nei_list[0] == 1:
            num = 0
        else:
            num = nei_list[0]
        for i in nei_list:
            if i > 1:
                curr_frequency = nei_list.count(i)
                if curr_frequency > counter:
                    counter = curr_frequency
                    num = i
        if num > 1:
            num_of_nums = nei_list.count(num)
            if 3 <= num_of_nums:
                return int(num)
            else:
                return 0
        else:
            return 0

    @staticmethod
    def evaluate_id_rule_3(nei_list):  # Choose the id which is the most frequent in neighbourhood
        counter = 0
        if nei_list[0] == 1:
            num = 0
        else:
            num = nei_list[0]
        for i in nei_list:
            if i > 1:
                curr_frequency = nei_list.count(i)
                if curr_frequency > counter:
                    counter = curr_frequency
                    num = i
        if num > 1:
            num_of_nums = nei_list.count(num)
            if 3 <= num_of_nums:
                return int(num)
            else:
                return 0
        else:
            return 0

    @staticmethod
    def evaluate_id_rule_4(nei_list, probability_threshold):
        counter = 0
        if nei_list[0] == 1:
            num = 0
        else:
            num = nei_list[0]
        for i in nei_list:
            if i > 1:
                curr_frequency = nei_list.count(i)
                if curr_frequency > counter:
                    counter = curr_frequency
                    num = i
        if num > 1:
            if probability_threshold <= np.random.randint(1, 101):
                return int(num)
            else:
                return 0
        else:
            return 0

    def one_step(self):                         # One step of cellular automaton with GBC feature
        space_prev = dp(self.space)
        for x in range(self.space_width):
            for y in range(self.space_width):
                if space_prev[x, y] == self.cell_empty:
                    if   self.check_rule_1(space_prev, x, y):
                        continue
                    elif self.check_rule_2(space_prev, x, y):
                        continue
                    elif self.check_rule_3(space_prev, x, y):
                        continue
                    elif self.check_rule_4(space_prev, x, y):
                        continue
                    else:
                        continue
                elif space_prev[x, y] == self.cell_inclusion:
                    continue
                else:
                    continue
        return self.space
